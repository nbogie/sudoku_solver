[1mdiff --git a/Sudoku.hs b/Sudoku.hs[m
[1mindex a6689d3..e6fbc89 100644[m
[1m--- a/Sudoku.hs[m
[1m+++ b/Sudoku.hs[m
[36m@@ -1,7 +1,6 @@[m
import Control.Monad (join, foldM) -- join :: Monad m => m (m a) -> m a [m
import Data.Char (digitToInt)[m
import Data.List (delete, nub, minimumBy, maximumBy, find)[m
[31mimport Data.Maybe (isJust)[m
import Data.Ord (comparing)[m
import qualified Data.Map as M[m
import Text.Printf (printf)[m
[36m@@ -12,6 +11,8 @@[m [mimport Text.Printf (printf)[m
rowNames = "ABCDEFGHI"[m
colNames = "123456789"[m

[32mtype Error = String[m

type Board = M.Map Square Values[m
type Values = [Int][m
type Square = String[m
[36m@@ -50,10 +51,10 @@[m [mparseBoardNoCP str = M.fromList $ zip squares str[m

--Make a board from a simple parsed board by trying to run full assignment of [m
--each of its filled-in values (detects conflict). Doesn't try to solve completely.[m
parseBoard :: String -> [31mMaybe[m[32mEither Error[m Board
parseBoard str = foldM asgn emptyBoard singles[m
  where [m
    asgn :: Board -> (Square, Int) -> [31mMaybe[m[32mEither Error[m Board
    asgn b (sq, v) = assign sq v b[m
    emptyBoard = M.fromList . zip squares $ repeat [1..9][m
    singles = [(s,head vs) | (s,vs) <- parseBoardToList str, length vs == 1][m
[36m@@ -87,54 +88,64 @@[m [mdemoBoard = parseBoard demo[m
---------------------------------------------------------------------------------[m
-- SOLVER[m
---------------------------------------------------------------------------------[m
solve :: String -> [31mMaybe[m[32mEither Error[m Board
solve str = parseBoard str >>= search[m

[32minstance Monad (Either e) where[m
[32m  Left l >>= _f = Left l[m
[32m  Right r >>= f = f r [m
[32m  return = Right[m

search :: Board -> [31mMaybe[m[32mEither Error[m Board
search b | allLenOne = [31mJust[m[32mreturn[m b --Finished!
         | otherwise = [m
  [31mjoin .[m[32mcase[m find [31misJust[m[32misRight[m . map (\d -> assign squareWithFewestChoices d b >>= search) $ choices [32mof[m
[32m    Just (Right soln) -> Right soln[m
[32m    Nothing -> Left "various searches failed (so various errors"[m 
  where [m
    allLenOne = all ((==1) . length . (b M.!)) squares[m
    (squareWithFewestChoices, choices) = [m
      minimumBy (comparing (length . snd)) [(s, vs) | s <- squares, let vs = b M.! s, length vs > 1][m
    [32misRight :: Either a b -> Bool[m
[32m    isRight (Right _) = True[m
[32m    isRight _ = False[m

assign :: Square -> Int -> Board -> [31mMaybe[m[32mEither Error[m Board
assign s d b = [m
  foldM (eliminate s) b otherVals[m
    where otherVals = delete d $ b M.! s[m
  [m
--eliminate a digit from the given square, propagating constraints.[m
eliminate ::  Square -> Board -> Int -> [31mMaybe[m[32mEither Error[m Board
eliminate s b d = [m
  -- if we've already removed the value at that square, do nothing. [m
  if d `notElem` b M.! s[m
    then [31mJust[m[32mreturn[m b
    else [31mJust[m[32mreturn[m b >>= step1 s d >>= step2 s d

-- Remove digit from sq, and apply rule 1:[m
-- (1) If a square s is reduced to one value d2, [m
-- then eliminate d2 from the peers.[m
step1 ::  Square -> Int -> Board -> [31mMaybe[m[32mEither Error[m Board
step1 s d b = [m
  case delete d (b M.! s) of[m
    []   -> [31mNothing[m[32mLeft $ "Contradiction " ++ show (s, d, "no possibles")[m
    [d2] -> foldM elim (M.insert s [d2] b) (peersFor s)[m
              where elim b' p = eliminate p b' d2[m
    vs   -> [31mJust[m[32mreturn[m $ M.insert s vs b

-- Apply rule 2: [m
-- (2) If a unit u is reduced to only one place for a value d, [m
--     then put it there.[m
step2 :: Square -> Int -> Board -> [31mMaybe[m[32mEither Error[m Board
step2 s d board = foldM unitTrim board (unitsFor s)[m
  where [m
    unitTrim b unit = [m
      case unitSquaresWithVal unit d of[m
          []      -> [31mNothing          -- Contradiction: no place for this[m[32mLeft $ "No squares in unit have[m value [32m" ++ show (unit, d)[m
          [oneSq] -> assign oneSq d b -- d can only be in one place in unit; [m
                                      -- assign it there.[m
          _       -> [31mJust[m[32mreturn[m b
        where unitSquaresWithVal u d = [s | s <- u, d `elem` (b M.! s)][m

---------------------------------------------------------------------------------[m
[36m@@ -144,7 +155,7 @@[m [mmain = interact $ unlines . map solveAndShow . lines[m
  where[m
  solveAndShow :: String -> String[m
  solveAndShow str = displayRaw (parseBoardNoCP str) ++ [m
                     "\n\n" ++ [31mmaybe "Can't solve"[m[32meither ("Can't solve because "++)[m display (solve str)

---------------------------------------------------------------------------------[m
-- Further work: [m
